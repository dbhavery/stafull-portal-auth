/**
 * SocketContext - Shared WebSocket context for all portals
 * Provides real-time connection to Core Engine via Socket.IO
 */

import { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react';
import { io } from 'socket.io-client';

// Get WebSocket URL based on environment
const getSocketUrl = () => {
  if (import.meta.env.DEV) {
    return 'http://localhost:3001';
  }
  return import.meta.env.VITE_WS_URL || 'https://api.stafull.com';
};

const SocketContext = createContext(null);

/**
 * SocketProvider - Wraps app with WebSocket connection
 * @param {Object} props
 * @param {React.ReactNode} props.children
 * @param {Object} props.user - Current authenticated user
 * @param {string} props.portalType - Type of portal (franchise, hq, driver, customer)
 */
export function SocketProvider({ children, user, portalType = 'franchise' }) {
  const [isConnected, setIsConnected] = useState(false);
  const [connectionError, setConnectionError] = useState(null);
  const socketRef = useRef(null);
  const listenersRef = useRef(new Map());

  // Initialize socket connection
  useEffect(() => {
    const token = localStorage.getItem('stafull_token') || localStorage.getItem('token');

    socketRef.current = io(getSocketUrl(), {
      transports: ['websocket', 'polling'],
      auth: token ? { token } : undefined,
      autoConnect: true,
      reconnection: true,
      reconnectionAttempts: 10,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
    });

    socketRef.current.on('connect', () => {
      setIsConnected(true);
      setConnectionError(null);

      // Join appropriate rooms based on portal type and user
      if (user?.franchiseId) {
        socketRef.current.emit('join:franchise', user.franchiseId);
      }

      // Portal-specific room joins
      if (portalType === 'hq') {
        socketRef.current.emit('join:hq');
      }

      if (import.meta.env.DEV) {
        console.log(`[Socket] Connected to ${getSocketUrl()} as ${portalType}`);
      }
    });

    socketRef.current.on('disconnect', (reason) => {
      setIsConnected(false);
      if (import.meta.env.DEV) {
        console.log('[Socket] Disconnected:', reason);
      }
    });

    socketRef.current.on('connect_error', (error) => {
      setConnectionError(error.message);
      if (import.meta.env.DEV) {
        console.error('[Socket] Connection error:', error.message);
      }
    });

    return () => {
      socketRef.current?.disconnect();
    };
  }, [user?.franchiseId, portalType]);

  // Subscribe to an event
  const on = useCallback((event, callback) => {
    if (!socketRef.current) return () => {};

    socketRef.current.on(event, callback);

    // Track listener for cleanup
    if (!listenersRef.current.has(event)) {
      listenersRef.current.set(event, []);
    }
    listenersRef.current.get(event).push(callback);

    // Return unsubscribe function
    return () => {
      socketRef.current?.off(event, callback);
      const listeners = listenersRef.current.get(event) || [];
      const index = listeners.indexOf(callback);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, []);

  // Subscribe once
  const once = useCallback((event, callback) => {
    if (!socketRef.current) return () => {};
    socketRef.current.once(event, callback);
    return () => socketRef.current?.off(event, callback);
  }, []);

  // Unsubscribe from an event
  const off = useCallback((event, callback) => {
    socketRef.current?.off(event, callback);
  }, []);

  // Emit an event
  const emit = useCallback((event, data) => {
    if (!socketRef.current?.connected) {
      if (import.meta.env.DEV) {
        console.warn('[Socket] Cannot emit - not connected');
      }
      return;
    }
    socketRef.current.emit(event, data);
  }, []);

  // Emit with acknowledgment
  const emitWithAck = useCallback((event, data, timeout = 5000) => {
    return new Promise((resolve, reject) => {
      if (!socketRef.current?.connected) {
        reject(new Error('Socket not connected'));
        return;
      }

      const timer = setTimeout(() => {
        reject(new Error('Socket acknowledgment timeout'));
      }, timeout);

      socketRef.current.emit(event, data, (response) => {
        clearTimeout(timer);
        resolve(response);
      });
    });
  }, []);

  // Join a room
  const joinRoom = useCallback((room) => {
    emit('join:room', room);
  }, [emit]);

  // Leave a room
  const leaveRoom = useCallback((room) => {
    emit('leave:room', room);
  }, [emit]);

  const value = {
    socket: socketRef.current,
    isConnected,
    connectionError,
    on,
    once,
    off,
    emit,
    emitWithAck,
    joinRoom,
    leaveRoom,
  };

  return (
    <SocketContext.Provider value={value}>
      {children}
    </SocketContext.Provider>
  );
}

/**
 * useSocket - Hook to access socket context
 */
export function useSocket() {
  const context = useContext(SocketContext);
  if (!context) {
    throw new Error('useSocket must be used within a SocketProvider');
  }
  return context;
}

/**
 * useSocketEvent - Convenience hook to subscribe to a single event
 * @param {string} event - Event name to subscribe to
 * @param {Function} callback - Callback function
 */
export function useSocketEvent(event, callback) {
  const { on } = useSocket();

  useEffect(() => {
    if (!event || !callback) return;
    return on(event, callback);
  }, [event, callback, on]);
}

/**
 * useFranchiseSocket - Franchise-specific socket hook
 * Subscribes to common franchise events
 */
export function useFranchiseSocket() {
  const socket = useSocket();
  const [drivers, setDrivers] = useState([]);
  const [alerts, setAlerts] = useState([]);
  const [deliveries, setDeliveries] = useState([]);

  useEffect(() => {
    const unsubDrivers = socket.on('drivers:update', setDrivers);
    const unsubAlerts = socket.on('alerts:new', (alert) => {
      setAlerts(prev => [alert, ...prev].slice(0, 50));
    });
    const unsubDeliveries = socket.on('deliveries:update', setDeliveries);

    return () => {
      unsubDrivers();
      unsubAlerts();
      unsubDeliveries();
    };
  }, [socket]);

  return {
    ...socket,
    drivers,
    alerts,
    deliveries,
    clearAlerts: () => setAlerts([]),
  };
}

/**
 * useHQSocket - HQ-specific socket hook
 * Subscribes to system-wide events
 */
export function useHQSocket() {
  const socket = useSocket();
  const [franchises, setFranchises] = useState([]);
  const [systemAlerts, setSystemAlerts] = useState([]);

  useEffect(() => {
    const unsubFranchises = socket.on('franchises:update', setFranchises);
    const unsubAlerts = socket.on('system:alert', (alert) => {
      setSystemAlerts(prev => [alert, ...prev].slice(0, 100));
    });

    return () => {
      unsubFranchises();
      unsubAlerts();
    };
  }, [socket]);

  return {
    ...socket,
    franchises,
    systemAlerts,
    clearSystemAlerts: () => setSystemAlerts([]),
  };
}

export default SocketContext;
