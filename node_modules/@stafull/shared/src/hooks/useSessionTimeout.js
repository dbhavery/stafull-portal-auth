/**
 * useSessionTimeout hook
 * Monitors session timeout for internal users
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import { useAuth } from '../contexts/AuthContext';

const DEFAULT_TIMEOUT_MS = 30 * 60 * 1000; // 30 minutes
const DEFAULT_WARNING_MS = 25 * 60 * 1000; // 25 minutes

export function useSessionTimeout(options = {}) {
  const {
    timeoutMs = DEFAULT_TIMEOUT_MS,
    warningMs = DEFAULT_WARNING_MS,
    onWarning,
    onTimeout,
  } = options;

  const { user, requiresTimeout, logout } = useAuth();

  const [timeRemaining, setTimeRemaining] = useState(null);
  const [showWarning, setShowWarning] = useState(false);

  const lastActivityRef = useRef(Date.now());
  const intervalRef = useRef(null);

  // Reset the timer
  const resetTimer = useCallback(() => {
    lastActivityRef.current = Date.now();
    setShowWarning(false);
  }, []);

  // Handle user activity
  const handleActivity = useCallback(() => {
    resetTimer();
  }, [resetTimer]);

  // Update time remaining
  useEffect(() => {
    if (!user || !requiresTimeout) {
      setTimeRemaining(null);
      setShowWarning(false);
      return;
    }

    const updateTimer = () => {
      const elapsed = Date.now() - lastActivityRef.current;
      const remaining = Math.max(0, timeoutMs - elapsed);

      setTimeRemaining(remaining);

      // Check warning threshold
      if (remaining <= (timeoutMs - warningMs) && remaining > 0) {
        if (!showWarning) {
          setShowWarning(true);
          onWarning?.();
        }
      }

      // Check timeout
      if (remaining === 0) {
        onTimeout?.();
        logout();
      }
    };

    // Initial update
    updateTimer();

    // Start interval
    intervalRef.current = setInterval(updateTimer, 1000);

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [user, requiresTimeout, timeoutMs, warningMs, showWarning, onWarning, onTimeout, logout]);

  // Setup activity listeners
  useEffect(() => {
    if (!user || !requiresTimeout) return;

    const events = ['mousedown', 'keydown', 'touchstart'];

    events.forEach((event) => {
      window.addEventListener(event, handleActivity, { passive: true });
    });

    return () => {
      events.forEach((event) => {
        window.removeEventListener(event, handleActivity);
      });
    };
  }, [user, requiresTimeout, handleActivity]);

  // Format time remaining
  const formatTimeRemaining = useCallback(() => {
    if (timeRemaining === null) return null;

    const minutes = Math.floor(timeRemaining / 60000);
    const seconds = Math.floor((timeRemaining % 60000) / 1000);

    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  }, [timeRemaining]);

  return {
    timeRemaining,
    formattedTime: formatTimeRemaining(),
    showWarning,
    resetTimer,
    isActive: requiresTimeout,
  };
}

export default useSessionTimeout;
