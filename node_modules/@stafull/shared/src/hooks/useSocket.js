/**
 * useSocket - WebSocket Hook for Real-Time Updates
 * Connects to Core Engine Socket.IO server
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import { io } from 'socket.io-client';

// Default WebSocket URL based on environment
const getSocketUrl = () => {
  if (import.meta.env.VITE_WS_URL) {
    return import.meta.env.VITE_WS_URL;
  }
  if (import.meta.env.DEV) {
    return 'http://localhost:3001';
  }
  return 'https://api.stafull.com';
};

/**
 * useSocket - Establishes and manages Socket.IO connection
 *
 * @param {Object} options - Configuration options
 * @param {string} options.url - Socket.IO server URL (optional)
 * @param {string} options.room - Room to join (e.g., 'franchise:123', 'hq')
 * @param {boolean} options.autoConnect - Whether to connect automatically (default: true)
 * @param {Function} options.onConnect - Callback when connected
 * @param {Function} options.onDisconnect - Callback when disconnected
 * @param {Function} options.onError - Callback on error
 *
 * @returns {Object} Socket state and methods
 */
export function useSocket(options = {}) {
  const {
    url = getSocketUrl(),
    room = null,
    autoConnect = true,
    onConnect,
    onDisconnect,
    onError,
  } = options;

  const [isConnected, setIsConnected] = useState(false);
  const [connectionError, setConnectionError] = useState(null);
  const socketRef = useRef(null);
  const listenersRef = useRef(new Map());

  // Initialize socket connection
  useEffect(() => {
    if (!autoConnect) return;

    const token = localStorage.getItem('stafull_token') || localStorage.getItem('token');

    socketRef.current = io(url, {
      transports: ['websocket', 'polling'],
      autoConnect: true,
      reconnection: true,
      reconnectionAttempts: Infinity,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      auth: token ? { token } : undefined,
    });

    const socket = socketRef.current;

    socket.on('connect', () => {
      setIsConnected(true);
      setConnectionError(null);
      if (import.meta.env.DEV) {
        console.log('[Socket] Connected:', socket.id);
      }
      onConnect?.();

      // Join room if specified
      if (room) {
        if (room.startsWith('franchise:')) {
          socket.emit('join:franchise', room.split(':')[1]);
        } else if (room === 'hq') {
          socket.emit('join:hq');
        } else {
          socket.emit('join', room);
        }
      }
    });

    socket.on('disconnect', (reason) => {
      setIsConnected(false);
      if (import.meta.env.DEV) {
        console.log('[Socket] Disconnected:', reason);
      }
      onDisconnect?.(reason);
    });

    socket.on('connect_error', (error) => {
      setConnectionError(error.message);
      if (import.meta.env.DEV) {
        console.error('[Socket] Connection error:', error.message);
      }
      onError?.(error);
    });

    return () => {
      if (room) {
        if (room.startsWith('franchise:')) {
          socket.emit('leave:franchise', room.split(':')[1]);
        }
      }
      socket.disconnect();
      socketRef.current = null;
    };
  }, [url, room, autoConnect, onConnect, onDisconnect, onError]);

  /**
   * Subscribe to an event
   */
  const on = useCallback((event, callback) => {
    if (!socketRef.current) return () => {};

    socketRef.current.on(event, callback);

    // Track listeners for cleanup
    if (!listenersRef.current.has(event)) {
      listenersRef.current.set(event, new Set());
    }
    listenersRef.current.get(event).add(callback);

    // Return unsubscribe function
    return () => {
      socketRef.current?.off(event, callback);
      listenersRef.current.get(event)?.delete(callback);
    };
  }, []);

  /**
   * Subscribe to an event once
   */
  const once = useCallback((event, callback) => {
    if (!socketRef.current) return;
    socketRef.current.once(event, callback);
  }, []);

  /**
   * Unsubscribe from an event
   */
  const off = useCallback((event, callback) => {
    if (!socketRef.current) return;

    if (callback) {
      socketRef.current.off(event, callback);
      listenersRef.current.get(event)?.delete(callback);
    } else {
      socketRef.current.off(event);
      listenersRef.current.delete(event);
    }
  }, []);

  /**
   * Emit an event
   */
  const emit = useCallback((event, data) => {
    if (!socketRef.current || !isConnected) {
      console.warn('[Socket] Cannot emit - not connected');
      return false;
    }
    socketRef.current.emit(event, data);
    return true;
  }, [isConnected]);

  /**
   * Emit with acknowledgement
   */
  const emitWithAck = useCallback((event, data) => {
    return new Promise((resolve, reject) => {
      if (!socketRef.current || !isConnected) {
        reject(new Error('Not connected'));
        return;
      }
      socketRef.current.emit(event, data, (response) => {
        if (response?.error) {
          reject(new Error(response.error));
        } else {
          resolve(response);
        }
      });
    });
  }, [isConnected]);

  /**
   * Manually connect
   */
  const connect = useCallback(() => {
    if (socketRef.current && !socketRef.current.connected) {
      socketRef.current.connect();
    }
  }, []);

  /**
   * Manually disconnect
   */
  const disconnect = useCallback(() => {
    if (socketRef.current) {
      socketRef.current.disconnect();
    }
  }, []);

  /**
   * Join a room
   */
  const joinRoom = useCallback((roomName) => {
    if (!socketRef.current || !isConnected) return;

    if (roomName.startsWith('franchise:')) {
      socketRef.current.emit('join:franchise', roomName.split(':')[1]);
    } else if (roomName === 'hq') {
      socketRef.current.emit('join:hq');
    } else {
      socketRef.current.emit('join', roomName);
    }
  }, [isConnected]);

  /**
   * Leave a room
   */
  const leaveRoom = useCallback((roomName) => {
    if (!socketRef.current) return;

    if (roomName.startsWith('franchise:')) {
      socketRef.current.emit('leave:franchise', roomName.split(':')[1]);
    } else {
      socketRef.current.emit('leave', roomName);
    }
  }, []);

  return {
    // State
    isConnected,
    connectionError,
    socket: socketRef.current,

    // Methods
    on,
    once,
    off,
    emit,
    emitWithAck,
    connect,
    disconnect,
    joinRoom,
    leaveRoom,
  };
}

/**
 * useSocketEvent - Convenience hook to subscribe to a single event
 */
export function useSocketEvent(socket, event, callback) {
  useEffect(() => {
    if (!socket || !event || !callback) return;

    socket.on(event, callback);
    return () => socket.off(event, callback);
  }, [socket, event, callback]);
}

/**
 * useDriverSocket - Driver-specific socket hook
 */
export function useDriverSocket(driverId, franchiseId) {
  const [locationUpdates, setLocationUpdates] = useState([]);
  const [deliveryUpdates, setDeliveryUpdates] = useState([]);
  const [alerts, setAlerts] = useState([]);

  const socket = useSocket({
    room: franchiseId ? `franchise:${franchiseId}` : null,
  });

  // Listen for driver-related events
  useEffect(() => {
    if (!socket.isConnected) return;

    const unsubLocation = socket.on('driver:location:update', (data) => {
      setLocationUpdates(prev => [...prev.slice(-99), data]);
    });

    const unsubDelivery = socket.on('delivery:status:update', (data) => {
      setDeliveryUpdates(prev => [...prev.slice(-49), data]);
    });

    const unsubAlert = socket.on('safety:alert', (data) => {
      setAlerts(prev => [...prev.slice(-19), data]);
    });

    return () => {
      unsubLocation();
      unsubDelivery();
      unsubAlert();
    };
  }, [socket.isConnected, socket.on]);

  // Emit location update
  const updateLocation = useCallback((location) => {
    socket.emit('driver:location', {
      driverId,
      franchiseId,
      ...location,
    });
  }, [socket, driverId, franchiseId]);

  // Emit mode change
  const updateMode = useCallback((mode) => {
    socket.emit('driver:mode', {
      driverId,
      franchiseId,
      mode,
    });
  }, [socket, driverId, franchiseId]);

  // Emit delivery status
  const updateDeliveryStatus = useCallback((deliveryId, status) => {
    socket.emit('delivery:status', {
      franchiseId,
      deliveryId,
      status,
      driverId,
    });
  }, [socket, driverId, franchiseId]);

  return {
    ...socket,
    locationUpdates,
    deliveryUpdates,
    alerts,
    updateLocation,
    updateMode,
    updateDeliveryStatus,
  };
}

export default useSocket;
